use crate::{err_msg, types::heap::BoxedBytes};

use super::{
    const_handles, BigIntApi, ErrorApi, ErrorApiImpl, Handle, ManagedBufferApi, ManagedTypeApi,
    ManagedTypeApiImpl,
};

pub trait EndpointArgumentApi {
    type EndpointArgumentApiImpl: EndpointArgumentApiImpl;

    fn argument_api_impl() -> Self::EndpointArgumentApiImpl;
}

/// Interface to only be used by code generated by the macros.
/// The smart contract code doesn't have access to these methods directly.
pub trait EndpointArgumentApiImpl: ErrorApi + ManagedTypeApi {
    fn endpoint_init(&self) {}

    fn get_num_arguments(&self) -> i32;

    fn load_argument_managed_buffer(&self, arg_index: i32, dest: Handle);

    fn get_argument_len(&self, arg_index: i32) -> usize {
        self.load_argument_managed_buffer(arg_index, const_handles::MBUF_TEMPORARY_1);
        Self::managed_type_impl().mb_len(const_handles::MBUF_TEMPORARY_1)
    }

    fn get_argument_boxed_bytes(&self, arg_index: i32) -> BoxedBytes {
        self.load_argument_managed_buffer(arg_index, const_handles::MBUF_TEMPORARY_1);
        Self::managed_type_impl().mb_to_boxed_bytes(const_handles::MBUF_TEMPORARY_1)
    }

    fn load_argument_big_int_unsigned(&self, arg_index: i32, dest: Handle) {
        self.load_argument_managed_buffer(arg_index, const_handles::MBUF_TEMPORARY_1);
        Self::managed_type_impl().mb_to_big_int_unsigned(const_handles::MBUF_TEMPORARY_1, dest);
    }

    fn load_argument_big_int_signed(&self, arg_index: i32, dest: Handle) {
        self.load_argument_managed_buffer(arg_index, const_handles::MBUF_TEMPORARY_1);
        Self::managed_type_impl().mb_to_big_int_signed(const_handles::MBUF_TEMPORARY_1, dest);
    }

    fn get_argument_u64(&self, arg_index: i32) -> u64 {
        self.load_argument_big_int_unsigned(arg_index, const_handles::BIG_INT_TEMPORARY_1);
        if let Some(value) = Self::managed_type_impl().bi_to_i64(const_handles::BIG_INT_TEMPORARY_1)
        {
            value as u64
        } else {
            Self::error_api_impl().signal_error(err_msg::ARG_OUT_OF_RANGE)
        }
    }

    fn get_argument_i64(&self, arg_index: i32) -> i64 {
        self.load_argument_big_int_signed(arg_index, const_handles::BIG_INT_TEMPORARY_1);
        if let Some(value) = Self::managed_type_impl().bi_to_i64(const_handles::BIG_INT_TEMPORARY_1)
        {
            value
        } else {
            Self::error_api_impl().signal_error(err_msg::ARG_OUT_OF_RANGE)
        }
    }

    fn load_callback_closure_buffer(&self, dest: Handle);

    // fn get_num_callback_closure_items(&self) -> i32 {
    //     // not yet implemented
    //     0
    // }

    // /// To managed buffer handle
    // fn load_callback_closure_item(&self, _arg_index: i32, _dest: Handle) {
    //     // not yet implemented
    //     self.signal_error(b"no closure items can be accessed at the moment")
    // }
}
